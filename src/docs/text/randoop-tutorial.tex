\documentclass[11pt, oneside]{article} % use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                        % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}
\usepackage{fullpage}
\usepackage{url}

\usepackage[parfill]{parskip}        % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}        % Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
                % TeX will automatically convert eps --> pdf in pdflatex    
\usepackage{amssymb}

%
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\cmd}[1]{{\texttt{#1}}}


\title{Randoop Tutorial}
%\date{December 7, 2016}              % Activate to display a given date or no date

\begin{document}
\maketitle
%\section{}
%\subsection{}

\section{Introduction}
Randoop is a random test generator for classes written in Java.
Given a set of Java classes, Randoop outputs two test suites:
\begin{itemize}
\item Error-revealing tests that indicate errors in the Java code.
\item Regression tests that capture current behavior, and that can identify
  when future code changes affect behavior.
\end{itemize}
Randoop creates large numbers of tests that may be too complicated too
mundane for the average programmer to write.
Randoop runs automatically.  The user can tune parameters and provide
optional inputs to improve Randoop's performance.

This tutorial is an introduction to using Randoop to generate tests, specifically in the context of the Pascali project.

\section{Getting Started}
This tutorial assumes that the Pascali \cmd{fetch.py} and \cmd{run.py}
scripts have been run.
The \cmd{fetch.py} script ensures that the Randoop jar file is available,
and the \cmd{run.py} script ensures that input files for Randoop (such as
the list of classes in the Pascali corpus) are there.

From the root directory of the Pascali project, run the
following commands to make links to files needed for the tutorial:
\begin{verbatim}
PASCALIROOT = `pwd`
git clone https://github.com/randoop/tutorial-examples.git
cd tutorial-examples
./gradlew -PpascaliRoot=$PASCALIROOT tutorialInit 
\end{verbatim}
% Concretely, this creates links to the Randoop jar file, as well as the
% files needed to run on one of the Pascali input cases.

\section{Learning about Randoop}\label{thebasics}
We will apply Randoop to a toy class, \texttt{MyInteger}.

\subsection{A buggy class}
First, run the command
\begin{verbatim}
./gradlew first build
\end{verbatim}

Before moving on, peek in the file \texttt{src/main/java/math/MyInteger.java}.
This is a simple class that creates integer-like objects that can be added and multiplied.
Programmer-crafted tests are in \texttt{src/test/java/math/MyIntegerTest.java}.
With a quick glance these look reasonable, but, as we'll see, this version of \code{MyInteger} has a bug.

When we ran the \cmd{build} Gradle task these files were compiled, and the tests were run.
But, to be sure, run the tests independently of the build:
\begin{verbatim}
./gradlew cleanTest test
\end{verbatim}
And, indeed, everything passes.

Now let's use Randoop to generate some tests.
Copy and paste the following command into your terminal to run Randoop:
\begin{verbatim}
 java -ea -cp build/classes/main:randoop.jar randoop.main.Main gentests \
   --testclass=math.MyInteger --junit-output-dir=src/test/java --outputlimit=20
\end{verbatim}
This will generate a small number of tests using the constructors and methods of the \texttt{math.MyInteger} class; writing them to the subdirectory \texttt{src/test/java}.
Randoop has actually generated two pairs of files: one for error-revealing tests, and one for regression tests.
For each pair, the file with the version number, such as \texttt{ErrorTest0.java}, is the JUnit class, and the file without (e.g., \texttt{ErrorTest.java}) is the JUnit4 test suite consisting of \code{ErrorTest0}.

The fact that Randoop generated the error-revealing tests means that it discovered code sequences that demonstrate the failure of a contract.
Looking in the file \texttt{src/test/java/ErrorTest0.java}, there are nine methods each which violate the same constract.
The first, slightly edited, is
\begin{verbatim}
public void test1() throws Throwable {
    math.MyInteger myInteger0 = new math.MyInteger();
    math.MyInteger myInteger1 = new math.MyInteger();
    math.MyInteger myInteger2 = new math.MyInteger();
    math.MyInteger myInteger3 = myInteger1.add(myInteger2);
    math.MyInteger myInteger4 = myInteger0.multiply(myInteger2);
    
    // Checks the contract:  equals-hashcode on myInteger3 and myInteger1
    org.junit.Assert.assertTrue(
      "Contract failed: equals-hashcode on myInteger3 and myInteger1", 
      myInteger3.equals(myInteger1) 
        ? myInteger3.hashCode() == myInteger1.hashCode() : true);
}
\end{verbatim}
This test checks the contract that encodes the convention that if two objects are equal, then they have the same \code{hashCode}.
This is the kind of test that is likely to be overlooked by a programmer, but is critical to the proper behavior of the class in the tests that the programmer wrote.

\vfill\pagebreak
Running 
\begin{verbatim}
./gradlew test
\end{verbatim}
now includes the Randoop generated tests, with the tests in \texttt{ErrorTest0.java} failing, and the tests in \texttt{RegressionTests0.java} passing.


The regression tests capture sequences of code that behaves well, along with assertions about the values that are generated. 
We'll look more closely at regression tests once we have eliminated the errors.

\subsection{Revised class}

If we look at the class (\texttt{src/main/java/math/MyInteger.java}) more closely than before, we can see that the equals method is poorly defined
\begin{verbatim}
public boolean equals(Object other) {
    if (other instanceof MyInteger) {
      return true;
    }
    return false;
}
\end{verbatim}
and there is no \code{hashCode()} method.

So, switch to a revised version of the class that fixes these problems.
Run the command
\begin{verbatim}
./gradlew second build
\end{verbatim}
to replace the buggy version of the class with the fixed one, and then the command
\begin{verbatim}
./gradlew build
\end{verbatim}
to compile the class and run the tests. 
Notice that all of the tests now pass.

\subsection{A regression}

\section{A Larger Example}\label{largerexample}
The tutorial, so far, has used simplistic inputs that don't completely demonstrate the advantages of Randoop. 
So, let's look at applying Randoop to a larger set of inputs.
The Pascali project \url{url-here} includes a collection of libraries over which Randoop and other tools are applied. 

The example we use here is from the Catalano Framework (\url{https://github.com/DiegoCatalano/Catalano-Framework})
\end{document}  
