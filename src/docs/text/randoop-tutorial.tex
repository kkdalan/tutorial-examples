\documentclass[11pt, oneside]{article} % use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                        % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}
\usepackage{fullpage}
\usepackage{url}

\usepackage[parfill]{parskip}        % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}        % Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
                % TeX will automatically convert eps --> pdf in pdflatex    
\usepackage{amssymb}

%
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\cmd}[1]{{\texttt{#1}}}


\title{Randoop Tutorial}
%\date{December 7, 2016}              % Activate to display a given date or no date

\begin{document}
\maketitle
%\section{}
%\subsection{}

\section{Introduction}
Randoop is a random test generator for classes written in Java; 
creating tests by exploring both known behavioral contracts as well as complex combinations of constructors and methods across classes.
The resulting tests are either error-revealing tests that identify suspected failures, or regression tests that capture current behavior.
These are tests that are too complicated, or even too mundane, for the average programmer to write, yet add coverage to a test suite at the cost of the runtime for Randoop (and, perhaps, some parameter tuning).

This tutorial is an introduction to using Randoop to generate tests, specifically in the context of the Pascali project.

\section{Getting Started}
This tutorial assumes that the Pascali \cmd{fetch.py} and \cmd{run.py} scripts have been run.
The first will ensure that the Randoop jar file is available, and the second will ensure that the files needed to run Randoop on files in the Pascali corpus are there.

Assuming you are in the root directory of the Pascali project, the following commands will setup the directory so that the tutorial steps will work:
\begin{verbatim}
PASCALIROOT = `pwd`
git clone https://github.com/randoop/tutorial-examples.git
cd tutorial-examples
./gradlew -PpascaliRoot=$PASCALIROOT tutorialInit 
\end{verbatim}
Concretely, this creates links to the Randoop jar file, as well as the files needed to run on one of the Pascali input cases.

\section{Learning about Randoop}\label{thebasics}
We start with a toy class so that we can explore the value of using Randoop.

\subsection{A buggy class}
First, run the command
\begin{verbatim}
./gradlew first build
\end{verbatim}

Before moving on, peek in the file \texttt{src/main/java/math/MyInteger.java}.
This is a simple class that creates integer-like objects that can be added and multiplied.
Programmer crafted tests are in \texttt{src/test/java/math/MyIntegerTest.java}.
With a quick glance these look reasonable, but, as we'll see, this version of \code{MyInteger} has a bug.

When we ran the \cmd{build} Gradle task these files were compiled, and the tests were run.
But, to be sure, run the tests independently of the build:
\begin{verbatim}
./gradlew cleanTest test
\end{verbatim}
And, indeed, everything passes.

Now let's use Randoop to generate some tests.
Copy and paste the following command into your terminal to run Randoop:
\begin{verbatim}
 java -ea -cp build/classes/main:randoop.jar randoop.main.Main gentests \
   --testclass=math.MyInteger --junit-output-dir=src/test/java --outputlimit=20
\end{verbatim}
This will generate a small number of tests using the constructors and methods of the \texttt{math.MyInteger} class; writing them to the subdirectory \texttt{src/test/java}.
Randoop has actually generated two pairs of files: one for error-revealing tests, and one for regression tests.
For each pair, the file with the version number, such as \texttt{ErrorTest0.java}, is the JUnit class, and the file without (e.g., \texttt{ErrorTest.java}) is the JUnit4 test suite consisting of \code{ErrorTest0}.

The fact that Randoop generated the error-revealing tests means that it discovered code sequences that demonstrate the failure of a contract.
Looking in the file \texttt{src/test/java/ErrorTest0.java}, there are five methods each which violate the same constract.
The second, slightly edited, is
\begin{verbatim}
public void test2() throws Throwable {
    math.MyInteger myInteger1 = new math.MyInteger((-1));
    math.MyInteger myInteger3 = new math.MyInteger((-1));
    java.lang.String str4 = myInteger3.toString();
    math.MyInteger myInteger5 = myInteger1.multiply(myInteger3);
    int i6 = myInteger1.getIntValue();
    
    // Checks the contract:  equals-hashcode on myInteger3 and myInteger5
    org.junit.Assert.assertTrue(
      "Contract failed: equals-hashcode on myInteger3 and myInteger5",
      myInteger3.equals(myInteger5) 
        ? myInteger3.hashCode() == myInteger5.hashCode() : true);
}
\end{verbatim}
This test checks the contract that encodes the convention that if two objects are equal, then they have the same \code{hashCode}.
This is the kind of test that is likely to be overlooked by a programmer, but is critical to the proper behavior of the class in the tests that the programmer wrote.

\vfill\pagebreak
Running 
\begin{verbatim}
./gradlew test
\end{verbatim}
now includes the Randoop generated tests, with the tests in \texttt{ErrorTest0.java} failing, and the tests in \texttt{RegressionTests0.java} passing.


The regression tests capture sequences of code that behaves well, along with assertions about the values that are generated. 
We'll look more closely at regression tests once we have eliminated the errors.

\subsection{Revised class}

If we look at the class (\texttt{src/main/java/math/MyInteger.java}) more closely than before, we can see that the equals method is poorly defined
\begin{verbatim}
public boolean equals(Object other) {
    if (other instanceof MyInteger) {
      return true;
    }
    return false;
}
\end{verbatim}
and there is no \code{hashCode()} method.

So, switch to a revised version of the class that fixes these problems.
Run the command
\begin{verbatim}
./gradlew second
\end{verbatim}
to replace the buggy version of the class with the fixed one, and then the command
\begin{verbatim}
./gradlew build
\end{verbatim}
to compile the class and run the tests. 
Notice that all of the tests now pass, even the error-revealing tests that had failed before.

\subsection{A regression}

As we just saw, the tests generated for a previous version of the code are useful for checking the behavior of newer versions of the code.
Let's create new regression tests for the \code{MyInteger} class.
First, run
\begin{verbatim}
./gradlew cleanRandoopRegressionTests
\end{verbatim}
to remove the existing set of tests, and then run Randoop again
\begin{verbatim}
 java -ea -cp build/classes/main:randoop.jar randoop.main.Main gentests \
   --testclass=math.MyInteger --junit-output-dir=src/test/java --outputlimit=200
\end{verbatim}
Notice that Randoop only generated new regression tests.
Also, we used a much larger value for \cmd{--outputlimit}, which determines the limit on the number of tests that will generated (the number of generated tests may be much smaller.)

The value of regression tests is that they help identify situations where the behavior has changed from before. 
Now, switch to a changed version with the command
\begin{verbatim}
./gradlew third 
\end{verbatim}
and watch closely what happens when the tests are run
\begin{verbatim}
./gradlew test 
\end{verbatim}
The test runner output shows that there is an \code{AssertionError} at line 54 of \code{RegressionTest0.java}, which is the last assertion in the second test:
\begin{verbatim}
public void test02() throws Throwable {

    if (debug) { System.out.format("%n%s%n","RegressionTest0.test02"); }

    math.MyInteger myInteger1 = new math.MyInteger((-1));
    math.MyInteger myInteger3 = new math.MyInteger((-1));
    java.lang.String str4 = myInteger3.toString();
    math.MyInteger myInteger5 = myInteger1.multiply(myInteger3);
    boolean b7 = myInteger5.equals((java.lang.Object)(short)100);
    int i8 = myInteger5.getIntValue();
    
    // Regression assertion (captures the current behavior of the code)
    org.junit.Assert.assertTrue("'" + str4 + "' != '" + "-1"+ "'", str4.equals("-1"));
    
    // Regression assertion (captures the current behavior of the code)
    org.junit.Assert.assertNotNull(myInteger5);
    
    // Regression assertion (captures the current behavior of the code)
    org.junit.Assert.assertTrue(b7 == false);
    
    // Regression assertion (captures the current behavior of the code)
    org.junit.Assert.assertTrue(i8 == 1);

}
\end{verbatim}
This assertion says that integer value of the product of -1 with itself  should be 1.
But, since the assertion fails, there is either something wrong with \code{MyInteger.getIntValue()} or with \code{MyInteger.multiply()}.
If we look in the new \code{MyInteger}, the problem is that we've changed \code{multiply} to avoid the product of arbitrary negative numbers, and messed up the logic of correcting the sign:
\begin{verbatim}
public MyInteger multiply(MyInteger other) {
    int a = Math.abs(this.value);
    int b = Math.abs(other.value);
    int product = a * b;
    if (this.value < 0 || other.value < 0) {
      return new MyInteger(-1 * product);
    }
    return new MyInteger(product);
  }
\end{verbatim}

\section{A Larger Example}\label{largerexample}
The tutorial, so far, has used simplistic inputs that don't completely demonstrate the advantages of Randoop. 
So, let's look at applying Randoop to a larger set of inputs.
The Pascali project \url{url-here} includes a collection of libraries over which Randoop and other tools are applied. 

The example we use here is from the Catalano Framework (\url{https://github.com/DiegoCatalano/Catalano-Framework})
\end{document}  
