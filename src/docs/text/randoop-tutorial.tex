\documentclass[11pt, oneside]{article} % use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                        % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}
\usepackage{fullpage}
\usepackage{url}

\usepackage[parfill]{parskip}        % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}        % Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
                % TeX will automatically convert eps --> pdf in pdflatex    
\usepackage{amssymb}

%
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\cmd}[1]{{\texttt{#1}}}

%make verbatim treat '`' correctly
\makeatletter
\let\@sverbatim\@verbatim
\def\@verbatim{\@sverbatim \verbatimwithtick}
{\catcode``=13 \gdef\verbatimwithtick{\chardef`=18 }} 
\makeatother

\title{Randoop Tutorial}
%\date{December 7, 2016}              % Activate to display a given date or no date

\begin{document}
\maketitle
%\section{}
%\subsection{}

\section{Introduction}
Randoop is a random test generator for classes written in Java.
Given a set of Java classes, Randoop outputs two test suites:
\begin{itemize}
\item Error-revealing tests that indicate errors in the Java code.
\item Regression tests that capture current behavior, and that can identify
  when future code changes affect behavior.
\end{itemize}
Randoop creates large numbers of tests that may be too complicated too
mundane for the average programmer to write.
Randoop runs automatically.  The user can tune parameters and provide
optional inputs to improve Randoop's performance.

This tutorial is an introduction to using Randoop to generate tests, specifically in the context of the Pascali project.

\section{Getting Started}
This tutorial assumes that the Pascali commands \cmd{fetch.py} and \cmd{run\_dyntrace.py}
scripts have been run:
\begin{verbatim}
  python fetch.py
  python run_dyntrace.py catalano
\end{verbatim}
The \cmd{fetch.py} script ensures that the Randoop jar file is available,
and the \cmd{run\_dyntrace.py} script ensures that input files for Randoop (such as
the list of classes in the Pascali corpus) are there.

From the root directory of the Pascali project, run the
following commands to make links to files needed for the tutorial:
\begin{verbatim}
  PASCALIROOT=`pwd`
  git clone https://github.com/randoop/tutorial-examples.git
  cd tutorial-examples
  ./gradlew -PpascaliRoot=$PASCALIROOT tutorialInit 
\end{verbatim}
% Concretely, this creates links to the Randoop jar file, as well as the
% files needed to run on one of the Pascali input cases.

\section{Learning about Randoop}\label{thebasics}
We will apply Randoop to a toy class, \texttt{MyInteger}.

\subsection{A buggy class}
First, run the command
\begin{verbatim}
  ./gradlew first build
\end{verbatim}

Before moving on, peek in the file \texttt{src/main/java/math/MyInteger.java}.
This is a simple class that creates integer-like objects that can be added and multiplied.
Programmer-crafted tests are in \texttt{src/test/java/math/MyIntegerTest.java}.
With a quick glance these look reasonable, but, as we'll see, this version of \code{MyInteger} has a bug.

When we ran the \cmd{build} Gradle task these files were compiled, and the tests were run.
But, to be sure, run the tests independently of the build:
\begin{verbatim}
  ./gradlew cleanTest test
\end{verbatim}
And, indeed, everything passes.

Now let's use Randoop to generate some tests.
Copy and paste the following command into your terminal to run Randoop:
\begin{verbatim}
 java -ea -cp build/classes/main:randoop.jar randoop.main.Main gentests \
   --testclass=math.MyInteger --junit-output-dir=src/test/java --outputlimit=20
\end{verbatim}
This will generate a small number of tests using the constructors and methods of the \texttt{math.MyInteger} class; writing them to the subdirectory \texttt{src/test/java}.
Randoop has actually generated two pairs of files: one for error-revealing tests, and one for regression tests.
For each pair, the file with the version number, such as \texttt{ErrorTest0.java}, is the JUnit class, and the file without (e.g., \texttt{ErrorTest.java}) is the JUnit4 test suite consisting of \code{ErrorTest0}.

The fact that Randoop generated the error-revealing tests means that it discovered code sequences that demonstrate the failure of a contract.
Looking in the file \texttt{src/test/java/ErrorTest0.java}, there are five methods each which violate the same constract.
The second, slightly edited, is
\begin{verbatim}
public void test2() throws Throwable {
    math.MyInteger myInteger1 = new math.MyInteger((-1));
    math.MyInteger myInteger3 = new math.MyInteger((-1));
    java.lang.String str4 = myInteger3.toString();
    math.MyInteger myInteger5 = myInteger1.multiply(myInteger3);
    int i6 = myInteger1.getIntValue();
    
    // Checks the contract:  equals-hashcode on myInteger3 and myInteger5
    org.junit.Assert.assertTrue(
      "Contract failed: equals-hashcode on myInteger3 and myInteger5",
      myInteger3.equals(myInteger5) 
        ? myInteger3.hashCode() == myInteger5.hashCode() : true);
}
\end{verbatim}
This test checks the contract that encodes the convention that if two objects are equal, then they have the same \code{hashCode}.
This is the kind of test that is likely to be overlooked by a programmer, but is critical to the proper behavior of the class in the tests that the programmer wrote.

Running 
\begin{verbatim}
  ./gradlew test
\end{verbatim}
now includes the Randoop generated tests, with the tests in \texttt{ErrorTest0.java} failing, and the tests in \texttt{RegressionTests0.java} passing.


The regression tests capture sequences of code that behaves well, along with assertions about the values that are generated. 
We'll look more closely at regression tests once we have eliminated the errors.

\subsection{Revised class}

If we look at the class (\texttt{src/main/java/math/MyInteger.java}) more closely than before, we can see that the equals method is poorly defined
\begin{verbatim}
public boolean equals(Object other) {
    if (other instanceof MyInteger) {
      return true;
    }
    return false;
}
\end{verbatim}
and there is no \code{hashCode()} method.

So, switch to a revised version of the class that fixes these problems.
Run the command
\begin{verbatim}
  ./gradlew second
\end{verbatim}
to replace the buggy version of the class with the fixed one, and then the command
\begin{verbatim}
  ./gradlew build
\end{verbatim}
to compile the class and run the tests. 
Notice that all of the tests now pass, even the error-revealing tests that had failed before.

\subsection{A regression}

As we just saw, the tests generated for a previous version of the code are useful for checking the behavior of newer versions of the code.
Let's create new regression tests for the \code{MyInteger} class.
First, run
\begin{verbatim}
  ./gradlew cleanRandoopRegressionTests
\end{verbatim}
to remove the existing set of tests, and then run Randoop again
\begin{verbatim}
 java -ea -cp build/classes/main:randoop.jar randoop.main.Main gentests \
   --testclass=math.MyInteger --junit-output-dir=src/test/java --outputlimit=200
\end{verbatim}
Notice that Randoop only generated new regression tests.
Also, we used a much larger value for \cmd{--outputlimit}, which determines the limit on the number of tests that will generated (the number of generated tests may be much smaller.)

The value of regression tests is that they help identify situations where the behavior has changed from before. 
Now, switch to a changed version with the command
\begin{verbatim}
  ./gradlew third 
\end{verbatim}
and watch closely what happens when the tests are run
\begin{verbatim}
  ./gradlew test 
\end{verbatim}
The test runner output shows that there is an \code{AssertionError} at line 54 of \code{RegressionTest0.java}, which is the last assertion in the second test:
\begin{verbatim}
public void test02() throws Throwable {

    if (debug) { System.out.format("%n%s%n","RegressionTest0.test02"); }

    math.MyInteger myInteger1 = new math.MyInteger((-1));
    math.MyInteger myInteger3 = new math.MyInteger((-1));
    java.lang.String str4 = myInteger3.toString();
    math.MyInteger myInteger5 = myInteger1.multiply(myInteger3);
    boolean b7 = myInteger5.equals((java.lang.Object)(short)100);
    int i8 = myInteger5.getIntValue();
    
    // Regression assertion (captures the current behavior of the code)
    org.junit.Assert.assertTrue("'" + str4 + "' != '" + "-1"+ "'", str4.equals("-1"));
    
    // Regression assertion (captures the current behavior of the code)
    org.junit.Assert.assertNotNull(myInteger5);
    
    // Regression assertion (captures the current behavior of the code)
    org.junit.Assert.assertTrue(b7 == false);
    
    // Regression assertion (captures the current behavior of the code)
    org.junit.Assert.assertTrue(i8 == 1);

}
\end{verbatim}
This assertion says that integer value of the product of -1 with itself  should be 1.
But, since the assertion fails, there is either something wrong with \code{MyInteger.getIntValue()} or with \code{MyInteger.multiply()}.
If we look in the new \code{MyInteger}, the problem is that we've changed \code{multiply} to avoid the product of arbitrary negative numbers, and messed up the logic of correcting the sign:
\begin{verbatim}
public MyInteger multiply(MyInteger other) {
    int a = Math.abs(this.value);
    int b = Math.abs(other.value);
    int product = a * b;
    if (this.value < 0 || other.value < 0) {
      return new MyInteger(-1 * product);
    }
    return new MyInteger(product);
  }
\end{verbatim}

\section{A Larger Example}\label{largerexample}
What we've seen so far is that Randoop can generate tests that find important bugs, and also can help find regressions that arise between versions of code. 
But, Randoop can do more than build tests for a single simple class, it can build complex tests for non-toy code bases such as those included in the Pascali corpus.

The example we use from the Pascali corpus is part of the Catalano Framework (\url{https://github.com/DiegoCatalano/Catalano-Framework}).
Running the following Gradle task runs Randoop on the files in \texttt{catalanoimage/classlist.txt} using the classpath in \texttt{catalanoimage/classpath.txt}.
(Several of the methods throw exceptions, so we redirect standard error to a log file.)
\begin{verbatim}
  ./gradlew runCatalanoExample 2> catalano-error-log.txt
\end{verbatim}
This run uses \cmd{--outputlimit=2000}, and generates 1062 regression tests, and 9 error-revealing tests.
\end{document}  
